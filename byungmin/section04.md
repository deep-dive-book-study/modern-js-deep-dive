## 4장 변수

### 변수 호이스팅
변수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징

- **var**: 선언과 동시에 `undefined`로 초기화
- **let, const**: 선언은 되지만 초기화 전까지 참조 불가 (TDZ)

### 값의 할당과 메모리 관리
자바스크립트 엔진은 변수 선언과 값의 할당을 각각 다른 시점에 실행한다.

1. 실행 시점의 분리
- 변수 선언: 평가 단계(런타임 이전)에 실행. 호이스팅에 의해 `undefined`으로 초기화
- 값의 할당: 실행 단계(런타임)에 실행. 할당 연산자(=)를 만나면 실제 값이 저장된다.

2. 메모리 동작 방식
- 공간 확보: 할당 시 기존 undefined가 저장된 공간을 덮어쓰지 않음
- 새로운 참조: 새로운 메모리 공간을 확보하여 값을 저장하고, 변수는 해당 주소를 가리킴

### 재할당 (Re-assignment)
1. 메커니즘
- 불변적 동작: 기존 메모리 공간에 저장된 값을 변경하는 것이 아니라, 새로운 메모리 공간을 확보하고 재할당된 값을 저장
- 참조 변경: 변수가 가리키는 메모리 주소를 기존 주소에서 새로운 주소로 교체

2. 불필요한 메모리 처리 (Garbage Collection)
- 대상: 재할당으로 인해 더 이상 아무도 참조하지 않게 된 메모리 공간(undefined, 참조하지 않는 값들)
- 해제: 가비지 콜렉터에 의해 메모리에서 자동 해제됨(수행 시점은 불분명)

**예시**
```javascript
// 1. [평가 단계] var score; 가 먼저 실행되어 메모리에 등록되고 undefined로 초기화됨 (호이스팅)
console.log(score); // 결과: undefined (참조 가능)

// 2. [런타임] 값의 할당 실행
score = 10; // 새로운 메모리 공간에 10을 저장하고 score가 이를 가리킴

// 3. [런타임] 변수 선언문은 이미 평가 단계에서 실행되었으므로 무시됨
var score; 

console.log(score); // 결과: 10

// 4. [재할당] 
score = 20; // 기존 10이 저장된 공간을 바꾸는 게 아니라, 새로운 공간에 20을 쓰고 주소를 교체
console.log(score); // 결과: 20
```

### 가비지 컬렉션(Garbage Collection)

1. 관리 주체: 자바스크립트 엔진
- 역할: 자바스크립트는 Java와 마찬가지로 `매니지드 언어(Managed Language)` <br>
  개발자가 직접 메모리를 할당하거나 해제하지 않고, `자바스크립트 엔진(V8, SpiderMonkey 등)`이 이를 전담

2. 주요 동작 원리: 도달 가능성(Reachability)
- 개념: **도달 가능한 값**은 메모리에서 유지되고, 도달 불가능한 값은 삭제된다.
- 루트(Root): 태생부터 도달 가능한 값 (예: 전역 변수, 현재 실행 중인 함수의 지역 변수와 매개변수 등)
- 마크 앤 스윕(Mark-and-Sweep) 알고리즘:
    - Mark: 루트에서 시작하여 참조를 타고 연결된 모든 객체를 방문하고 마크한다.
    - Sweep: 마크되지 않은(어디에서도 참조되지 않는) 객체를 메모리에서 삭제한다.

3. Java(JVM) GC와의 차이점
- JVM: Heap 영역을 Young/Old Generation으로 정교하게 나누고 다양한 알고리즘(G1, ZGC 등)을 선택 가능함
- JS 엔진(V8): 기본적으로 Generational GC 방식을 사용 <br>
  메모리를 `New Space(생존 기간이 짧은 객체)`와 `Old Space(오래 살아남은 객체)`로 나누어 관리한다.

### V8 엔진의 세대별 메모리 구조

1. Young Generation (New Space)
- 특징: 생성된 지 얼마 안 된 객체들이 저장된다. 대부분의 객체는 여기서 생성되고 곧 사라진다.
- 구성: JVM의 Survivor 영역과 유사하게 `Semi-space(두 개의 공간)`로 나뉨
    - **To-Space / From-Space**: 객체 생성 시 한쪽 공간에 할당되고, GC가 발생하면 살아남은 객체만 다른 쪽 공간으로 복사
- 알고리즘: **Scavenge** 복사 방식, 속도가 매우 빠르지만 메모리 오버헤드가 있다.

2. Old Generation (Old Space)
- 특징: Young Generation에서 두 번의 GC를 살아남은 객체가 이동(`Promotion`)해 오는 공간
- 구성: 메모리 사이즈가 크며, 객체들이 오랫동안 머무른다.
- 알고리즘: Mark-Sweep-Compact
    - Mark-Sweep: 사용되지 않는 객체 식별 및 삭제
    - Compact: 파편화된 메모리 조각들을 모아서 정리(Optimization)