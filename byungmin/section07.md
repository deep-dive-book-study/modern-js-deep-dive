## 7장 연산자

### 동등/일치 비교 연산자
1. 동등 비교 연산자 (==, Loose Equality)
- 특징: 좌항과 우항의 피연산자를 비교할 때, 먼저 **암묵적 타입 변환**을 통해 타입을 일치시킨 후 값을 비교한다.
- 위험성: 엔진이 임의로 타입을 바꾸기 때문에 예측하기 어려운 결과를 반환하며, 실무에서는 사용을 지양한다.

```javascript
// 동등 비교 -> 결과를 예측하기 어렵다.
'0' == 0;     // true (문자열 '0'이 숫자 0으로 변환됨)
0 == false;   // true (false가 숫자 0으로 변환됨)
'' == 0;      // true (빈 문자열이 숫자 0으로 변환됨)
```

2. 일치 비교 연산자 (===, Strict Equality)
- 특징: 좌항과 우항의 피연산자가 `타입도 같고 값도 같은 경우`에만 true를 반환한다.
- 주의사항:
  - NaN: NaN === NaN은 false다. NaN은 자신과 일치하지 않는 유일한 값이다. (체크 시 Number.isNaN() 사용)
  - 0: 0 === -0은 true다.

### Object.is 메서드
1. 배경: 일치 연산자(===)의 설계상 한계

일치 연산자는 다음 두 가지 케이스에서 직관적이지 않은 결과를 반환
- NaN 비교: NaN은 자신과 일치하지 않는 유일한 값으로 판단
```JavaScript
NaN === NaN; // false
```

- 0 비교: 양의 0(+0)과 음의 0(-0)을 동일하다고 판단
```JavaScript
0 === -0; // true
```

2. Object.is의 도입 (ES6)

예외적인 케이스까지 정확히 비교하기 위해 도입됨. 예측 가능한 정밀한 동일성을 보장
- NaN 비교: true 반환
```JavaScript
Object.is(NaN, NaN); // true
```

- 0 비교: false 반환
```JavaScript
Object.is(0, -0); // false
```

### Java의 비교연산자 개념 비교
자바의 **동일성(Identity)**과 동등성(Equality) 개념을 자바스크립트 연산자와 매칭하면 다음과 같다.

1. 동일성 (Identity) → === (일치 연산자)
- Java: `==` 연산자 (기본 타입은 값 비교, 참조 타입은 주소값 비교)
- JS `(===)`:
  - 원시 타입: 메모리에 저장된 값이 같은지 확인
  - 객체 타입: 메모리 힙의 참조 주소가 같은지 확인 (Java의 객체 `==`와 동일)

2. 동등성 (Equality) → == (동등 연산자)
- Java: `equals()` 메서드 (논리적으로 데이터의 내용이 같은지 비교)
- JS `(==)`:
  - 타입을 강제로 맞춰서라도 값이 같은지 확인하려 한다.
  - **주의**: 자바의 `equals()`는 개발자가 논리적 재정의 할 수 있지만, JS의 `==`는 엔진이 정해진 규칙에 따라 강제로 변환하므로 자바의 동등성보다 훨씬 위험하고 느슨하다.