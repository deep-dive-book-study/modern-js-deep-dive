## 9장 타입 변환

### 타입 변환 (Type Conversion)
1. 암묵적 타입 변환 (Implicit Coercion)
- 정의: 개발자의 의도와 상관없이 **자바스크립트 엔진이 코드의 문맥을 고려해 자동으로 타입을 강제 변환**하는 현상
- 메커니즘: 표현식을 평가할 때 에러를 발생시키지 않도록 가급적 타입을 맞추며, 기존 값을 바탕으로 새로운 타입의 값을 생성하여 단 한 번 사용하고 버림
- 특징: 코드가 간결해지지만, 엔진의 변환 규칙을 모르면 결과를 예측하기 어려워 버그의 원인이 될 수 있다.

```javascript
'10' + 2;   // "102" (문자열 연결 문맥)
5 * '10';   // 50 (산술 연산 문맥)
!0;         // true (불리언 문맥)
```

2. 명시적 타입 변환 (Explicit Coercion)
- 정의: 개발자가 의도적으로 내장 함수나 연산자를 사용하여 값의 타입을 변경하는 것 (타입 캐스팅)
- 메커니즘: 표준 빌트인 생성자 함수(String, Number, Boolean)를 new 연산자 없이 호출하거나, 빌트인 메서드 등을 직접 사용
- 특징: 타입 변환 의도가 코드에 명확히 드러나므로 가독성과 유지보수성이 높아진다.

```javascript
String(10);           // "10"
parseInt('10.5');     // 10
Boolean(undefined);   // false
```

> 자바스크립트의 원시 값은 변경 불가능한 값(Immutable Value)이다. 따라서 타입 변환은 기존 변수에 저장된 값을 직접 수정하는 것이 아니라,
> **기존 값을 참조하여 새로운 타입의 값을 만들어내는 과정**

### 암묵적 타입 변환의 위험성
1. 코드 예측 불가능성 (Unpredictability)
- 문제: 개발자가 작성할 때 의도한 데이터 타입과 엔진이 변환한 타입이 다를 경우, 프로그램은 죽지 않고 계속 돌아가지만 `잘못된 결과(Silent Error)`를 산출한다.

2. 디버깅의 어려움
- 문제: **에러(Runtime Error)**가 발생하면 즉시 멈추고 위치를 알려주지만, 암묵적 변환은 잘못된 값을 들고 프로그램이 끝까지 실행된다.

3. 왜 자바스크립트는 이렇게 설계되었을까?
- 웹 브라우저의 특성: 
  - 초창기 자바스크립트는 웹 페이지의 아주 간단한 상호작용(버튼 클릭 등)을 위해 만들어짐
  - 사소한 타입 에러로 인해 브라우저 전체가 멈추거나 화면이 안 나오는 것을 방지하기 위해 최대한 관대하게 설계
- 스크립트 언어의 철학: 컴파일 단계가 없는 동적 타입 언어로서, 문법적 엄격함보다는 사용의 편의성과 유연성에 초점을 맞춤

### 단축 평가

**논리 연산자를 사용한 단축 평가**

- 논리 연산자는 좌항에서 우항으로 평가를 진행
- 논리적 결정권을 가진 피연산자를 만나는 즉시, 나머지 과정을 생략하고 해당 피연산자의 `값(Value)`을 그대로 반환

1. 논리합(`||`) 연산자: "하나라도 참이면 즉시 반환"
- 첫 번째 피연산자가 **참(Truthy)**이면, 두 번째는 볼 것도 없이 첫 번째 값을 반환
- 첫 번째가 **거짓(Falsy)**일 때만 두 번째 값까지 확인하고 반환
```javascript
// 왼쪽이 참이면 왼쪽 값을 반환
'Apple' || 'Banana'  // "Apple"
true || 'Banana'     // true

// 왼쪽이 거짓일 때만 오른쪽 값을 반환
null || 'Banana'     // "Banana"
0 || 'Banana'        // "Banana"
```

2. 논리곱(&&) 연산자: "둘 다 참이어야 하므로 끝까지 확인"
- 첫 번째 피연산자가 `참(Truthy)`이어도 전체 결과가 확정되지 않으므로, 두 번째 값까지 확인하고 두 번째 값을 반환
- 첫 번째가 `거짓(Falsy)`이면, 이미 전체 결과가 거짓이므로 즉시 첫 번째 값을 반환
```javascript
// 왼쪽이 참이면 오른쪽 값을 반환 (오른쪽까지 가봐야 알기 때문)
'Apple' && 'Banana'  // "Banana"
true && 'Banana'     // "Banana"

// 왼쪽이 거짓이면 즉시 왼쪽 값을 반환
null && 'Banana'     // null
false && 'Banana'    // false
```

**활용**
1. `||` 를 이용한 기본값 설정 (Default Value)
- 변수가 비어있을 때(null, undefined 등) 대체할 기본값을 지정할 때 유용
```javascript
var userName = ''; // 사용자가 이름을 입력 안 함 (빈 문자열 = Falsy)
var displayName = userName || '익명'; 

console.log(displayName); // "익명"
```

2. && 를 이용한 에러 방지 (Safe Navigation)
- 객체가 존재하는지 먼저 확인하고 그 프로퍼티를 참조할 때 사용
```javascript
var elem = null; // 객체가 없음

// elem이 null이면 뒤의 elem.value를 실행하지 않고 null을 반환하여 에러 방지
var value = elem && elem.value; 

console.log(value); // null (에러 발생 안 함)
```

**옵셔널 체이닝 연산자 (`?.`)**
- 목적: 객체의 프로퍼티에 접근할 때, 해당 객체가 null이나 undefined인 경우 에러를 내는 대신 undefined를 반환
- 단축 평가(`&&`)와의 차이: `&&`는 0이나 ''(빈 문자열)도 거짓으로 보고 평가를 멈추지만, `?.`는 오직 **null과 undefined**인 경우에만 멈춤
```javascript
var elem = null;
// elem이 null이므로 에러 없이 undefined 반환
var value = elem?.value; 

console.log(value); // undefined
```

**null 병합 연산자 (`??`)**
- 목적: 변수에 기본값을 설정할 때 사용
- 논리합(`||`)과의 차이: `||`는 0이나 ''(빈 문자열)도 거짓으로 취급해 기본값을 할당하지만, `??`는 오직 **null과 undefined**일 때만 우항의 기본값을 할당
```javascript
// || 연산자의 문제점: 0이나 빈 문자열을 유효한 값으로 쓰고 싶을 때도 기본값을 넣어버림
var foo = 0 || 'default'; // 'default' (0을 거짓으로 판단)

// ?? 연산자: null, undefined일 때만 기본값 작동
var bar = 0 ?? 'default'; // 0 (0은 null/undefined가 아니므로 그대로 유지)
```