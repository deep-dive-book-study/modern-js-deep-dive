## 11장 원시 값과 객체의 비교

### 문자열과 불변성
1. 문자열의 생성과 메모리
- 특징: 문자열은 0개 이상의 문자로 이뤄진 집합이며, 1개의 문자당 2바이트의 메모리 공간을 점유한다.
- 숫자 타입은 10이든 1000000이든 동일한 8바이트를 사용하지만, 문자열은 글자 수에 따라 메모리 크기가 결정된다.
- 메모리 할당: 자바스크립트 엔진은 문자열이 생성될 때마다 메모리에 고유한 문자열 값을 할당한다.

2. 문자열은 왜 원시 값인가?
- 불변성: 한 번 생성된 문자열은 읽기 전용이며 절대로 수정할 수 없음
- 재할당 동작: 기존 문자열을 수정하는 것처럼 보여도, 실제로는 메모리에 완전히 새로운 문자열을 생성하고 변수가 그곳을 가리키도록 주소를 변경

```javascript
var str = 'Hello';
str = 'world';
// 새로운 공간에 'world'를 만들고 str이 참조하게 된다.
```

3. 유사 배열 객체로서의 문자열
- 정의: 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며, length 프로퍼티를 갖는 유사 배열 객체
- 읽기 전용: 배열처럼 인덱스로 접근하여 특정 문자를 바꾸려고 시도해도 반영되지 않는다. (에러는 발생하지 않지만 무시됨)
```javascript
var str = 'string';

// 인덱스로 읽기 가능
console.log(str[0]); // "s"

// 인덱스로 수정 시도 (불변성 때문에 불가능)
str[0] = 'S';
console.log(str); // "string" (수정되지 않음)
```

### 값에 의한 전달 (Pass by Value) / 참조에 의한 전달 (Pass by Reference)
1. 값에 의한 전달 (Pass by Value)
- 대상: 원시 타입 (Number, String, Boolean, null, undefined, Symbol)
- 동작: 변수에 원시 값을 할당하면, 실제 값의 복사본이 생성되어 전달된다.
- 특징: 두 변수는 서로 다른 메모리 공간에 저장된 별개의 값이므로, 한쪽을 변경해도 다른 쪽에 아무런 영향을 주지 않는다.
```javascript
var score = 80;
var copy = score; // 값 80이 복사되어 전달됨

score = 100; // 원본 변경

console.log(score); // 100
console.log(copy);  // 80 (복사본은 유지됨)
```

2. 참조에 의한 전달 (Pass by Reference)
- 대상: 객체 타입 (Object, Array, Function 등)
- 동작: 변수에 객체를 할당하면 실제 값이 아닌, 값이 저장된 `메모리 주소(참조 값)`가 전달된다.
- 특징: 두 변수가 동일한 메모리 주소를 가리키고 있으므로, 한쪽에서 객체를 수정하면 다른 쪽 변수를 통해 접근했을 때도 변경된 내용이 반영된다.
```javascript
var person = { name: 'Lee' };
var copy = person; // 주소(참조 값)가 복사되어 전달됨

copy.name = 'Kim'; // 참조를 통해 객체 수정

console.log(person.name); // 'Kim' (원본도 변경됨)
console.log(copy.name);   // 'Kim'
```

3. 결국 "값에 의한 전달"과 "참조에 의한 전달"은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다.
- 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다.

### 자바스크립트 객체의 저장 방식
1. 해시 테이블(Hash Table) 기반의 구조
- 대부분의 자바스크립트 엔진(V8 등)은 객체를 기본적으로 해시 테이블과 유사한 방식으로 관리
- 특징: 객체는 프로퍼티 키를 해시 함수에 입력하여 얻은 해시 값을 인덱스로 사용하여 프로퍼티 값을 저장
- 유연성: 클래스 정의 없이도 프로퍼티를 동적으로 추가하고 삭제할 수 있다.

2. 히든 클래스(Hidden Class)와 최적화
- 하지만 일반적인 해시 테이블은 프로퍼티 접근 속도가 느리다는 단점이 있다. 이를 극복하기 위해 V8 엔진은 `히든 클래스(Hidden Class)`라는 개념을 도입
- 동작 원리: 자바의 클래스처럼 객체의 `모양(구조)`을 고정하여, 프로퍼티가 메모리의 어느 오프셋(위치)에 있는지 미리 계산해 둔다.
- 최적화: 동일한 구조를 가진 객체들은 같은 히든 클래스를 공유하게 되어, 해시 테이블을 매번 뒤지는 것보다 훨씬 빠르게 값에 접근할 수 있다.

### 얕은 복사 (Shallow Copy) / 깊은 복사 (Deep Copy)
1. 얕은 복사 (Shallow Copy)
- 정의: 객체를 복사할 때, 한 단계까지만 복사하는 방식
- 동작: 객체에 중첩되어 있는 객체(내부 객체)가 있다면, 그 내부 객체는 참조 값(주소)만 복사된다.
- 결과: 원본과 복사본이 내부 객체를 공유하게 되며, 따라서 복사본의 내부 객체를 수정하면 원본도 영향을 받는다.
```javascript
const original = { a: 1, b: { c: 2 } };

// 전개 연산자를 이용한 얕은 복사
const copy = { ...original };

copy.a = 100;      // 1단계 값 변경
copy.b.c = 200;    // 내부 객체 값 변경

console.log(original.a);   // 1 (원본 유지)
console.log(original.b.c); // 200 (원본도 변경됨!)
```

2. 깊은 복사 (Deep Copy)
- 정의: 객체에 중첩되어 있는 모든 객체를 포함하여, 전체를 완전히 새로 복사하는 방식
- 동작: 원시 값은 물론 내부 객체들까지 모두 새로운 메모리 공간에 다시 생성한다.
- 결과: 원본과 복사본은 서로 완벽하게 독립된 상태가 되며, 한쪽을 수정해도 다른 쪽에 전혀 영향을 주지 않는다.
```javascript
const original = { a: 1, b: { c: 2 } };

// JSON을 이용한 깊은 복사 (가장 간단한 방법 중 하나)
const copy = JSON.parse(JSON.stringify(original));

copy.b.c = 999;

console.log(original.b.c); // 2 (원본이 보호됨)
console.log(copy.b.c);     // 999
```