## 12장 함수

### 함수 정의 방식
1. 함수 선언문 (Function Declaration)
- 가장 기본적인 방식이며, 자바에서 메서드를 만드는 것과 유사한 형태
- 형태: `function 함수이름(매개변수) { ... }`
- 특징: 함수 이름을 생략할 수 없으며, 함수 호이스팅이 발생하여 선언 전에도 호출이 가능하다.
```javascript
function add(x, y) {
  return x + y;
}
```
2. 함수 표현식 (Function Expression)
- 정의: 자바스크립트 함수는 값처럼 변수에 할당할 수 있는 일급 객체이므로, 함수 리터럴로 생성한 함수 객체를 변수에 할당하여 정의하는 방식
- 형태: `var add = function (x, y) { ... };`
- 특징:
  - 함수 리터럴의 함수 이름을 생략하는 익명 함수 방식이 일반적
  - 변수 호이스팅이 발생하여 변수는 선언되지만, 실제 함수 할당은 런타임에 이루어지므로 할당문 이전 호출 시 TypeError가 발생함
  - 함수 이름: 표현식에서 함수 이름을 붙여도(var add = function foo() {}), 그 이름은 함수 내부에서만 유효하며 외부에서는 변수명(add)으로만 호출 가능
```javascript
// 함수 리터럴에서 이름을 생략하고 변수 add에 할당
var add = function (x, y) {
  return x + y;
};

// 식별자(변수명) add를 통해 호출
console.log(add(5, 5)); // 10
```


### 함수 선언문의 세부 동작
1. 표현식이 아닌 문으로서의 특징
- 함수 선언문은 변수 선언문과 마찬가지로 표현식이 아닌 문이다.
- 따라서 단독으로 사용될 때 변수에 할당할 수 없지만, 자바스크립트 엔진이 문맥에 따라 중의적으로 해석할 수 있다.
  - 단독 사용: 함수 선언문(문)으로 해석
  - 값의 자리(할당문 등): 함수 리터럴 표현식으로 해석하여 객체를 생성함

2. 함수 이름과 식별자의 관계
- 함수 이름의 한계: 함수 이름은 함수 몸체 내부에서만 참조할 수 있는 식별자, 원래대로라면 외부에서 함수 이름으로 함수를 호출하는 것은 불가능
- 엔진의 암묵적 식별자 생성: 엔진은 함수 선언문을 해석할 때 함수 이름과 동일한 이름의 식별자를 메모리에 암묵적으로 생성하고, 그곳에 함수 객체를 할당한다.

결론적으로 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다.

### 함수의 생성 시점과 호이스팅
1. 함수의 생성 시점
- 함수 선언문: 런타임 이전에 엔진에 의해 먼저 실행됨
  - 코드가 한 줄씩 실행되는 런타임이 시작되기 전에, 자바스크립트 엔진은 코드 전체를 훑으며 함수 선언문을 찾아 함수 객체를 미리 생성해 둠
- 함수 표현식: 런타임에 평가되어 함수 객체가 생성됨
  - 변수 할당문과 마찬가지로, 코드가 실행 흐름에 따라 해당 줄에 도달했을 때 비로소 함수 리터럴이 평가되어 함수 객체가 되고 변수에 할당됨

2. 호이스팅 (Hoisting) 동작의 차이
- 함수 선언문 (함수 호이스팅)
  - 런타임 이전에 함수 생성과 식별자 할당이 모두 완료된 상태
  - 따라서 함수 선언문 이전 위치에서도 함수를 호출할 수 있다.
- 함수 표현식 (변수 호이스팅)
  - 함수 표현식은 변수에 할당하는 문이므로 '변수 호이스팅' 규칙을 따른다.
  - 런타임 이전에는 변수만 선언되고 undefined로 초기화
  - 함수 할당 전 호출 시, 변수 값인 undefined를 함수처럼 호출하는 꼴이 되어 `TypeError`가 발생한다.
```javascript
// 1. 함수 선언문: 호이스팅 가능
console.log(add(2, 5)); // 7 (정상 호출)

function add(x, y) {
  return x + y;
}

// 2. 함수 표현식: 호이스팅 불가 (변수 호이스팅만 발생)
console.log(sub(5, 2)); // TypeError: sub is not a function
// 현재 sub는 undefined 상태

var sub = function (x, y) {
  return x - y;
};
```

### 콜백 함수 (Callback Function)
1. 정의
- 함수의 매개변수를 통해 다른 함수 내부로 전달되는 함수를 콜백 함수라고 한다.
- 이때 콜백 함수를 전달받은 함수를 `고차 함수(Higher-Order Function, HOF)`라고 부른다.

2. 핵심 원리
- 제어권 위임: 고차 함수는 전달받은 콜백 함수의 호출 시점을 결정한다. 즉, 콜백 함수는 고차 함수에 의해 필요에 따라 호출된다.
- 유연성: 고차 함수는 외부에서 콜백 함수를 주입받기 때문에, 함수 내부 로직을 수정하지 않고도 동작을 자유롭게 바꿀 수 있다. (변경되지 않는 공통 로직은 고차 함수에, 매번 변하는 개별 로직은 콜백 함수에 담는 방식)
```javascript
// 고차 함수: n번만큼 반복하며 콜백 함수 f를 호출함
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i); // i를 인수로 전달하며 콜백 함수 호출
  }
}

// 콜백 함수 정의 1
var logAll = function (i) { console.log(i); };
repeat(3, logAll); // 0, 1, 2

// 콜백 함수 정의 2 (홀수만 출력하는 로직을 외부에서 주입)
var logOdds = function (i) {
  if (i % 2) console.log(i);
};
repeat(3, logOdds); // 1
```