### 12장 함수

#### 함수란?

일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
-> 코드 중복을 억제하고 재사용성 증가, 코드 가독성 향상

#### 함수는 일급객체

일급 객체: 값의 성질을 갖는 객체
함수가 일반 객체와 다른 점

- 호출 가능
- 함수 객체만의 고유한 프로퍼티
  -> 함수가 객체라는 사실은 Js의 주요한 특징

#### 함수 정의 방법: 함수 선언문 vs 함수 리터럴

##### 함수 선언문

```js
function add(x, y) {
  return x + y;
}
```

- 이름 생략 불가능
- 표현식이 아닌 문
- Js 엔진이 함수 이름으로 암묵적으로 식별자를 생성 후 함수 객체를 할당
- 함수 호이스팅 발생

##### 함수 리터럴(함수 표현식)

```js
add = function 생략가능한_함수_이름(x, y) {
  return x + y;
};
```

- 이름 생략 가능
- 표현식인 문
- `생략가능한_함수_이름`으로 호출 불가능 식별자 `add`로 호출
- 변수 호이스팅 발생

##### 함수 호이스팅 vs 변수 호이스팅

호이스팅: Js 엔진이 런타임 이전에 선언문이 먼저 실행되어 식별자 생성
함수 호이스팅: 암묵적으로 생성된 식별자가 **함수 객체**로 초기화됨
변수 호이스팅: 암묵적으로 생성된 식별자가 **undefined**로 초기화됨

-> 함수는 호출하기 전에 반드시 선언해야한다는 규칙을 지키기 위해 함수 리터럴 사용 권장

#### 함수 정의 방법: Function 생성자 함수

```js
var add = new Function("x", "y", "return x + y");
```

- 사용 지양
- 함수 선언문, 함수 표현식이랑 다르게 동작(클로저 비생성 등)

#### 함수 정의 방법: ES6 화살표 함수

```js
var add = (x, y) => x + y;
```

- 항상 익명 함수로 정의
- 생성자 함수로 사용불가
- 기존 함수와 this 바인딩 방식 다름
- prototype 프로퍼티 없음
- arguments 객체 비생성

#### 즉시 실행 함수

함수 정의와 동시에 즉시 호출되는 함수

- 익명 함수 사용
- 딱 한번만 쓰여야 할 때 사용

#### 재귀 함수

자기 자신을 호출하는 함수

- 반복되는 처리를 위해 사용
- 무한 반복, 스택 오버플로 에러 발생 가능성

#### 중첩 함수

함수 내부에 정의된 함수
(중첩 함수를 포함하는 함수: 외부함수)

#### 콜백 함수

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
(콜백 함수를 전달 받는 함수: 고차 함수)

익명 함수로 전달시: 매번 새로 생성
함수 정의 후 전달시: 1번만 생성

#### 순수 함수

어떤 외부 상태에 의존하지도 않고, 변경하지도 않는 함수

- 동일한 인수가 전달되면 언제나 동일한 값 반환

#### 비순수 함수

외부 상태에 의존하거나, 외부 상태를 변경하는(부수효과가 있는) 함수

- 외부 상태에 따라 반환값이 달라짐
- 외부 상태를 직접 참조하거나, 인수로 객체를 전달받으면 비순수 함수가 됨

-> 비순수 함수를 쓰면 상태 변화를 예측하기 힘들어짐
-> 비순수 함수 최대한 줄이기

#### 함수형 프로그래밍

순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍
