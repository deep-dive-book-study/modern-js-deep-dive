### 19장 프로토타입

자바스크립트는 프로토타입의 객체지향 언어

#### 객체지향 프로그래밍

프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 프로그래밍 절차지향적 관점에서 벗어나 여러개의 독립적 단위(객체의 집합)으로 프로그램을 표현하는 프로그래밍 패러다임

**추상화** : 다양한 속성 중에서 프로그램에 필요한 속성만 간추려 내어 표현하는 것

**객체** : 속성을 통해 여러개의 값을 하나의 단위로 구성한 복합적인 자료구조

#### 상속과 프로토타입

모든 인스턴스가 동일한 내용의 메서드를 사용, 소유, 중복 생성 -> 메모리 낭비 문제
prototype을 기반으로 상속을 구현하여 해결

```js
// Before
function Circle(radius) {
  this.radius = radius;
  this.getArea = function () {
    return Math.PI * this.radius ** 2;
  };
}

//After
function Circle(radius) {
  this.radius = radius;
}

Circle.prototype.getArea = function () {
  return Math.PI * this.radius ** 2;
}; //모든 Circle의 인스턴스는 하나의 getArea를 공유
```

#### 프로토타입 객체

객체지향 프로그래밍의 근간을 이루는 객체 간 상속을 구현하기 위해 사용

- `[[Prototype]]`이라는 내부슬롯을 가짐
- 모든 객체는 하나의 프로토타입을 가짐
- 모든 프로토타입은 생성자함수와 연결되어 있음
- 모든 객체는 `__proto__` 접근자 프로퍼티를 통해 자신의 프로토타입에 간접적으로 접근 가능(Object.prototype의 프로퍼티)

  **`__proto__`을 통해 간접적으로 접근하는 이유**: 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함

  -> 프로토타입 체인은 **단방향 링크드 리스트**로 구현되어야함

- `__proto__`를 직접 사용하는 것은 비표준, `Object.getPrototypeOf`,`Object.setPrototypeOf` 사용 권장

#### 함수 객체의 prototype 프로퍼티

함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킴
**주의**: non-constructor(화살표 함수, ES6 매서드 축약표현)으로 정의한 메서드는 prototype을 소유하지 않고, 프로토타입을 생성하지도 않음

#### 프로토타입의 constructor 프로퍼티와 생성자 함수

모든 프로토타입은 constructor 프로퍼티를 가짐
-> constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 **생성자 함수**를 가리킴

#### 프로토타입의 생성시점

생성자 함수가 생성되는 시점에 생성
-> 프로토타입과 생성자 함수는 쌍으로 존재하기 때문

생성자 함수의 종류

- 사용자 정의 생성자 함수
  - 함수 객체를 생성하는 시점에 프로토타입 생성
- JS 기본 제공 빌트인 생성자 함수
  - 빌트인 생성자 함수가 생성되는 시점에 프로토타입 생성
  - 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성

#### 객체 생성 방식

객체 생성 방식

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- 클래스(ES6)
  세부적인 생성 방식은 차이가 있으나 **추상연산 OrdinaryObjectCreate**
  에 의해 생성

#### 프로토타입 체인

객체의 프로퍼티(메서드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 `[[Prototype]]` 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색
-> 상속과 프로퍼티 검색을 위한 매커니즘

Object.prototype: 프로토타입 체인의 종점, 모든 객체가 상속받음

#### 오버라이딩

인스턴스에서 매서드 오버라이딩을 할 때 덮어씌우지 않고 인스턴스 프로퍼티로 추가

#### 프로퍼티 섀도잉

오버라이딩 할 때 프로토타입 메서드가 가려지는 현상

#### 프로토타입의 교체

프로토타입은 임의의 다른 객체로 변경 가능하지만 권장하지 않음

#### instanceof 연산자

우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true, 아니면 false

```js
객체 instanceof 생성자함수;
```

#### 직접 상속

1. Object.create를 이용해 명시적으로 프로토타입을 지정하여 새로운 객체 생성
   - new 연산자 없이도 객체 생성 가능
   - 프로토타입을 지정하면서 객체를 생성할 수 있음
   - 객체 리터럴에 의해 생성된 객체로 상속받을 수 있음
2. 객체 리터럴 내부에서 `__prototype__` 접근자 프로퍼티 사용

#### 정적 프로퍼티/메서드

생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드
-> 인스턴스로 참조/호출할 수 없음
ex) Object.create()

#### 프로퍼티 존재 확인

1. in 연산자
   - 확인 대상 객체가 상속받는 모든 프로토타입의 프로퍼티를 확인함
2. Object.prototype.hasOwnPrototype
   - 객체 고유의 프로퍼티 키인 경우에만 true

#### 프로퍼티 열거

1. for...in문
   - 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 `[[Enumerable]]`이 true인 프로퍼티를 순회하며 열거
   - 프로퍼티 키가 심벌인 프로퍼티는 열거X
   - 열거할 때 순서를 보장하지 않음
2. Object.keys/values/entries 메서드
   - 객체 자신의 프로퍼티만 열거
